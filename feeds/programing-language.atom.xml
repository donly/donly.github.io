<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>MAG's Note - Programing Language</title><link href="https://magicalboy.com/" rel="alternate"></link><link href="https://magicalboy.com//feeds/programing-language.atom.xml" rel="self"></link><id>https://magicalboy.com/</id><updated>2017-11-23T15:54:43+08:00</updated><entry><title>Objective C</title><link href="https://magicalboy.com/Objective-C.html" rel="alternate"></link><published>2017-11-23T15:54:43+08:00</published><updated>2017-11-23T15:54:43+08:00</updated><author><name>Don</name></author><id>tag:magicalboy.com,2017-11-23:/Objective-C.html</id><summary type="html">&lt;div class="contents topic" id="id1"&gt;
&lt;p class="topic-title first"&gt;目录&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id17"&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id18"&gt;类&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id19"&gt;声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id20"&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id21"&gt;属性&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id22"&gt;声明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id23"&gt;方法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id9" id="id24"&gt;类方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#block" id="id25"&gt;Block 块&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#protocol" id="id26"&gt;Protocol 协议&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id10" id="id27"&gt;声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id11" id="id28"&gt;使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#category" id="id29"&gt;Category 分类&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id12" id="id30"&gt;声明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id13" id="id31"&gt;Objective C 类型&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id14" id="id32"&gt;类型和字面常量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id15" id="id33"&gt;编译器指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id16" id="id34"&gt;其它&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id17"&gt;介绍&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Objective-C 作为 C 程序设计语言的超集，支持与 C 相同的基本语法。您会看到所有熟悉的元素，例如基本类型（&lt;tt class="docutils literal"&gt;int&lt;/tt&gt;、&lt;tt class="docutils literal"&gt;float&lt;/tt&gt; 等）、结构、函数、指针，以及流程控制结构，如 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;if...else&lt;/span&gt;&lt;/tt&gt; 语句和 &lt;tt class="docutils literal"&gt;for&lt;/tt&gt; 语句。还可以直接使用 C 标准库 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="contents topic" id="id1"&gt;
&lt;p class="topic-title first"&gt;目录&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id17"&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id18"&gt;类&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id19"&gt;声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id20"&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id21"&gt;属性&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id22"&gt;声明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id23"&gt;方法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id9" id="id24"&gt;类方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#block" id="id25"&gt;Block 块&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#protocol" id="id26"&gt;Protocol 协议&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id10" id="id27"&gt;声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id11" id="id28"&gt;使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#category" id="id29"&gt;Category 分类&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id12" id="id30"&gt;声明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id13" id="id31"&gt;Objective C 类型&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id14" id="id32"&gt;类型和字面常量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id15" id="id33"&gt;编译器指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id16" id="id34"&gt;其它&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id17"&gt;介绍&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Objective-C 作为 C 程序设计语言的超集，支持与 C 相同的基本语法。您会看到所有熟悉的元素，例如基本类型（&lt;tt class="docutils literal"&gt;int&lt;/tt&gt;、&lt;tt class="docutils literal"&gt;float&lt;/tt&gt; 等）、结构、函数、指针，以及流程控制结构，如 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;if...else&lt;/span&gt;&lt;/tt&gt; 语句和 &lt;tt class="docutils literal"&gt;for&lt;/tt&gt; 语句。还可以直接使用 C 标准库，例如 stdlib.h 和 stdio.h。&lt;/p&gt;
&lt;p&gt;Objective-C 为 ANSI C 添加了下述语法和功能：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;定义新的类&lt;/li&gt;
&lt;li&gt;类和实例方法&lt;/li&gt;
&lt;li&gt;方法调用（称为发消息）&lt;/li&gt;
&lt;li&gt;属性声明（以及通过它们自动合成存取方法）&lt;/li&gt;
&lt;li&gt;静态和动态类型化&lt;/li&gt;
&lt;li&gt;块 (block)，已封装的、可在任何时候执行的多段代码&lt;/li&gt;
&lt;li&gt;基本语言的扩展，例如协议和类别&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id18"&gt;类&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;如同其他大多数面向对象语言那样，Objective-C 中的类，支持数据的封装，并定义对这些数据执行的操作。对象是类的运行时实例。它包含自己的实例变量（由其类声明）的内存副本，以及类方法的指针。您可以采用两步法（称为分配和初始化）创建对象。&lt;/p&gt;
&lt;p&gt;Objective-C 中某个类包括两个不同的部分：接口和实现。接口部分包含类声明，并定义该类的公共接口。如同 C 代码那样，您定义头文件和源代码文件，将公共声明与代码的实现细节分开。如果是私有的，将它们放在实现文件中。这些文件的文件扩展名，列在下表中。&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="5%" /&gt;
&lt;col width="95%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;扩展名&lt;/th&gt;
&lt;th class="head"&gt;源类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;.h&lt;/td&gt;
&lt;td&gt;头文件。头文件包含类、类型、函数和常量声明。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;.m&lt;/td&gt;
&lt;td&gt;实现文件。可以同时包含 Objective-C 代码和 C 代码。有时也称为源文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;.mm&lt;/td&gt;
&lt;td&gt;实现文件。除了包含 Objective-C 代码和 C 代码以外，还可以包含 C++ 代码。仅当您实际引用您的 Objective-C 代码中的 C++ 类或功能时，才使用此扩展名。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id19"&gt;声明&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如下图中的语法声明名为 MyClass 的类，它是从基础类（或根类）NSObject 继承而来的。（根类是供其他类直接或间接继承的类。）类声明以编译器指令 &amp;#64;interface 开始，以 &amp;#64;end 指令结束。类名称后面（以冒号分隔），是父类的名称。在 Objective-C 中，一个类只能有一个父类。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;img alt="类的声明" class="align-center" src="http://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOSCh/chapters/WriteObjective-CCode/Art/class_decl_2x.png" style="width: 496px; height: 208px;" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在 &amp;#64;interface 指令和 &amp;#64;end 指令之间，编写属性和方法的声明。这些声明组成了类的公共接口。公共接口相关的自定函数、常量或数据类型的声明放在 &amp;#64;interface ...&amp;#64;end 块之外。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id20"&gt;实现&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;类实现的语法和声明相似。以 &amp;#64;implementation 编译器指令开始（接着是该类的名称），以 &amp;#64;end 指令结束。中间是方法实现。（函数实现应在 &amp;#64;implementation ...&amp;#64;end 块之外。）一个实现应该总是将导入它的接口文件作为代码的第一行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#import &amp;quot;MyClass.h&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;@implementation&lt;/span&gt; &lt;span class="bp"&gt;MyClass&lt;/span&gt;

&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;initWithString:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;aName&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// code goes here&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;MyClass&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;myClassWithString:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;aName&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// code goes here&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当您想要在源代码中包括头文件时，请在头文件或源文件的前几行之中，指定一个导入 (#import) 指令，#import 指令类似于 C 的 #include 指令，不过前者确保同一文件只被包括一次。如果您要导入框架的大部分或所有头文件，请导入框架的包罗头文件 (umbrella header file)，它具有与框架相同的名称。导入（假设的）QuartzCore 框架的头文件的语法是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#import &amp;lt;QuartzCore/QuartzCore.h&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id21"&gt;属性&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;属性通常是指某些由对象封装或储存的数据。它可以是标志（如名称或颜色），也可以是与一个或多个其他对象的关系。一个对象的类定义一个接口，该接口使其对象的用户能获取并设定所封装属性的值。执行这些操作的方法，称为 &lt;strong&gt;存取方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;存取方法有两种类型，命名约定：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;“getter” 存取方法返回属性的值，且名称与属性相同。&lt;/li&gt;
&lt;li&gt;“setter” 存取方法设定属性的新值，且形式为 setPropertyName:，其中属性名称的第一个字母大写。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正确命名的存取方法是 Cocoa 和 Cocoa Touch 框架的多种技术的关键元素，如 &lt;strong&gt;键－值编码&lt;/strong&gt;  (KVC)，它的机制是，通过对象的名称间接访问对象的属性。&lt;/p&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id22"&gt;声明&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Objective-C 提供属性声明(&amp;#64;property)编译器指令作为一种方便的写法，用于存取方法的声明和实现。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@property&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;nonatomic&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;userName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用属性声明，指定您想要的行为。编译器接着可以根据该声明，创建或合成实际的 getter 和 setter 方法。已声明的属性减少了您必须编写的样板文件代码量，因此使代码更简洁、更少机会出错。&lt;/p&gt;
&lt;p&gt;编译器自动合成所声明的属性。在合成属性时，它创建自己的存取方法，以及“支持”该属性的专有实例变量。实例变量的名称与属性的名称相同，但具有下划线前缀 (_)。只有在对象初始化和取消分配的方法中，您的应用程序应该直接访问实例变量（而不是其属性）。&lt;/p&gt;
&lt;p&gt;注意：在 Xcode4.4 之后不需要 &lt;tt class="docutils literal"&gt;&amp;#64;synthesize property&lt;/tt&gt;，会自动生成 &lt;tt class="docutils literal"&gt;&amp;#64;synthesize property = _property&lt;/tt&gt;。&lt;/p&gt;
&lt;p&gt;如果您想要让实例变量采用不同名称，可以绕过自动合成，并明确地合成属性。在类实现中使用 &amp;#64;synthesize 编译器指令，让编译器产生存取方法，以及进行特殊命名的实例变量。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@synthesize&lt;/span&gt; &lt;span class="n"&gt;enabled&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_isEnabled&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时，在声明属性时，您可以指定存取方法的自定名称，通常是使 Boolean 属性的 getter 方法遵循约定形式，如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@property&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;getter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;isEnabled&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;enabled&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Assign new value, change name of getter method&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于包含对象的变量，Objective-C 既支持动态类型化，也支持静态类型化。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;静态变量：静态类型化的变量，要在变量类型声明中包括类名称。&lt;/li&gt;
&lt;li&gt;动态变量：动态类型化的变量，则要给对象使用类型 id。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;MyClass&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myObject1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// Static typing&lt;/span&gt;
&lt;span class="kt"&gt;id&lt;/span&gt;       &lt;span class="n"&gt;myObject2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// Dynamic typing&lt;/span&gt;
&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;userName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// From Your First iOS App (static typing)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意第一个声明中的星号 (*)。在 Objective-C 中，执行对象引用的只能是指针。不能完全理解也不用担心，并非一定要成为指针专家才能开始 Objective-C 编程。码农只需要记住，在静态类型化的对象的声明中，变量的名称前面应放置一个星号。id 类型意味着一个指针。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id23"&gt;方法&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Objective-C 中有两种类型的方法：实例方法和类方法。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;实例方法&lt;/strong&gt;，由类的实例来执行。换言之，在调用实例方法之前，必须先创建该类的实例。实例方法是最常见的方法类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类方法&lt;/strong&gt;，可由它所在的类直接执行。它不需要对象的实例作为消息的接收者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法声明包含方法类型标识符、返回类型、一个或多个签名关键词，以及参数类型和名称信息。以下是 insertObject:atIndex: 实例方法的声明。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;img alt="方法声明语法" class="align-center" src="http://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOSCh/chapters/WriteObjective-CCode/Art/method_decl_2x.png" style="width: 492px; height: 252px;" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;对于实例方法，声明前面是减号 (-)；对于类方法，对应指示器是加号 (+)。
一个方法的实际名称 (insertObject:atIndex:) 由方法签名关键词组成，之间用冒号字符分隔。冒号字符表明有参数存在。在上述示例中，该方法采用两个参数。如果方法没有参数，则省略第一个签名关键词后面的冒号。&lt;/p&gt;
&lt;p&gt;当您想要调用一个方法时，通过给实现该方法的对象发送一则消息来实现。消息包含方法名称，以及方法所需的参数信息（类型要匹配）。您发送到一个对象的所有消息，都被动态地分派，这样使 Objective-C 类的多态行为更加容易。（多态性是指不同类型的对象响应同一消息的能力。）有时被调用的方法，是由接收消息对象的类之超类来实现。&lt;/p&gt;
&lt;p&gt;要发消息，需要一个消息表达式。&lt;strong&gt;消息表达式&lt;/strong&gt; 使用方括号（[ 和 ]）将消息本身（以及任何所需参数）括起来，同时将接收消息的对象放在最左边方括号右侧。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myArray&lt;/span&gt; &lt;span class="nl"&gt;insertObject&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;anObject&lt;/span&gt; &lt;span class="nl"&gt;atIndex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为避免声明大量局部变量来储存临时结果，Objective-C 让您嵌套消息表达式。每个嵌套表达式的返回值，都用作另一个消息的一个参数或接收对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;myAppObject&lt;/span&gt; &lt;span class="n"&gt;theArray&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;insertObject&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="n"&gt;myAppObject&lt;/span&gt; &lt;span class="n"&gt;objectToInsert&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;atIndex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Objective-C (2.0) 还提供用于调用存取方法的点记法语法。&lt;strong&gt;存取方法&lt;/strong&gt; 获取并设定对象的状态，因此对于封装很重要，是所有对象的重要功能。对象隐藏或封装其状态，并显示接口，该接口是访问该状态的所有实例都通用的。使用点记法语法，您可以将上个示例重新编写为如下形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myAppObject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;theArray&lt;/span&gt; &lt;span class="nl"&gt;insertObject&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;myAppObject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;objectToInsert&lt;/span&gt; &lt;span class="nl"&gt;atIndex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用点记法语法进行赋值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;myAppObject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;theArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;aNewArray&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// 相当于&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myAppObject&lt;/span&gt; &lt;span class="nl"&gt;setTheArray&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;aNewArray&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在点记法表达式中，您不能使用对动态类型化的对象（类型为 id 的对象）的引用。&lt;/p&gt;
&lt;p&gt;TODO: 介绍方法属性&lt;/p&gt;
&lt;div class="section" id="id9"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id24"&gt;类方法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Objective C 的类方法，类似于 C++ 中的静态类方法。&lt;/p&gt;
&lt;p&gt;一般将类方法用作工厂方法创建类的新实例，或，访问与该类关联的一些共享信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;NSMutableArray&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// nil is essentially the same as NULL&lt;/span&gt;

&lt;span class="c1"&gt;// Create a new array and assign it to the myArray variable.&lt;/span&gt;
&lt;span class="n"&gt;myArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSMutableArray&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="block"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id25"&gt;Block 块&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;块是封装工作单元的对象，即可在任何时间执行的代码段。它们在本质上是可移植的匿名函数，可作为方法和函数的参数传入，或可从方法和函数中返回。块本身具有一个已类型化的参数列表，且可能具有推断或声明的返回类型。您还可以将块赋值给变量，然后像调用函数一样调用它。&lt;/p&gt;
&lt;p&gt;插入符号 (^) 是用作块的语法标记。块的参数、返回值和正文（即执行的代码）存在其他类似的语法约定。下图解释了该语法，尤其是在将块赋值给变量时。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;img alt="Block 声明语法" class="align-center" src="http://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOSCh/chapters/WriteObjective-CCode/Art/blocks_2x.png" style="width: 570px; height: 210px;" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;您接着可以调用块变量，就像它是一个函数一样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;myBlock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// result is 28&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Block 可以在低版本 iOS 中使用，它只需要编译器 Xcode 支持。&lt;/p&gt;
&lt;p&gt;TODO: 深入&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="protocol"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id26"&gt;Protocol 协议&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;协议是一组尚未实现的方法列表，任何的类均可采纳该协议并给出方法的具体实现。&lt;/p&gt;
&lt;p&gt;协议经常应用于委托及事件触发。&lt;/p&gt;
&lt;p&gt;Objective-C中协议的概念与Java中接口的概念并不完全相同。&lt;/p&gt;
&lt;div class="section" id="id10"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id27"&gt;声明&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;类似于接口的声明，但没有父类，并且不能定义实例变量，尽管可以声明属性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@protocol&lt;/span&gt; &lt;span class="nc"&gt;MyProtocol&lt;/span&gt;

&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;myProtocolMethod&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，Protocol 也可以在声明时继承别的 Protocol。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 注意此处的 NSObject 是一个 Protocol&lt;/span&gt;
&lt;span class="k"&gt;@protocol&lt;/span&gt; &lt;span class="nc"&gt;MyProtocol&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="bp"&gt;NSObject&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;myProtocolMethod&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id28"&gt;使用&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;将该协议的名称放在尖括号 (&amp;lt;...&amp;gt;) 中，并且放在它继承的类的名称后面：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@interface&lt;/span&gt; &lt;span class="nc"&gt;SomeClass&lt;/span&gt; : &lt;span class="nc"&gt;SomeSuperClass&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;MyProtocol&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="category"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id29"&gt;Category 分类&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一个分类可以将方法的实现分解进一系列分离的文件。可让扩展类的接口而无需要对类进行实例化。&lt;/p&gt;
&lt;p&gt;Objective-C借用并扩展了Smalltalk实现中的“分类”概念。&lt;/p&gt;
&lt;p&gt;将类别用作一种手段，来对头文件内的相关方法声明进行分组。甚至还可以将不同的类别声明放在不同的头文件中。框架在其所有头文件中使用这些技巧，来达到清晰明确。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;img alt="系统框架中的类别" src="static/images/category.png" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Objective C 中的 Category 仅允许增加方法，不允许增加成员变量。&lt;/p&gt;
&lt;div class="section" id="id12"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id30"&gt;声明&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;声明类别语法，是使用圆括号将类别名称括起来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@interface&lt;/span&gt; &lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="nl"&gt;(NSExtendedArray)&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;arrayByAddingObject:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;anObject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类扩展匿名类别，在实现 (.m) 文件中声明专有属性和专有方法。类扩展看起来类似于类别，只是圆括号之间没有文本。在高版本的Xcode自动生成的 UIViewController 子类实现中可以看到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@interface&lt;/span&gt; &lt;span class="nc"&gt;MyAppDelegate&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;@property&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;MyDataObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在运行时，分类中的方法与类原有的方法并无区别，其代码可以访问包括私有类成员变量在内的所有成员变量。虽然分类可以访问类的私有成员，但通常利用属性的访问方法来访问是一种更好的做法，可以使得分类与原有类更加独立。&lt;/p&gt;
&lt;p&gt;若分类声明了与类中原有方法同名的函数，则分类中的方法会被调用。因此分类不仅可以增加类的方法，也可以代替原有的方法。这个特性可以用于修正原有代码中的错误，更可以从根本上改变程序中原有类的行为。若两个分类中的方法同名，则被调用的方法是不可预测的。&lt;/p&gt;
&lt;p&gt;允许动态的、按需的加载分类；若不需要某一分类提供的功能，可以简单的不编译之。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id13"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id31"&gt;Objective C 类型&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Objective-C 有几个不能用作变量名称的术语，保留用于特殊用途。其中包括已定义的类型以及与这些类型相配的字面常量，和以 &amp;#64; 符号为前缀的编译器指令。&lt;/p&gt;
&lt;div class="section" id="id14"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id32"&gt;类型和字面常量&lt;/a&gt;&lt;/h3&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="7%" /&gt;
&lt;col width="93%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;类型&lt;/th&gt;
&lt;th class="head"&gt;字面常量及描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;动态对象&lt;/strong&gt; 类型。动态类型化的对象和静态类型化的对象的否定字面常量，都是 nil。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Class&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;动态类&lt;/strong&gt; 类型。其否定字面常量是 Nil。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;SEL&lt;/td&gt;
&lt;td&gt;选择器的数据类型 (typedef)；此数据类型表示运行时的方法签名。其否定字面常量是 NULL。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;BOOL&lt;/td&gt;
&lt;td&gt;Boolean 类型。字面常量值是 YES 和 NO。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在某些情况下，这些类型和字面常量替换 ANSI C 相应的类型和字面常量。将消息发送到 nil，完全没有影响。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id15"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id33"&gt;编译器指令&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&amp;#64;interface&lt;/li&gt;
&lt;li&gt;&amp;#64;end&lt;/li&gt;
&lt;li&gt;&amp;#64;implementation&lt;/li&gt;
&lt;li&gt;&amp;#64;protocol&lt;/li&gt;
&lt;li&gt;&amp;#64;property&lt;/li&gt;
&lt;li&gt;&amp;#64;synthesize&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id16"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id34"&gt;其它&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;self : 引用当前对象；它等同于 C++ 中的 this。&lt;/li&gt;
&lt;li&gt;super : 引用超类对象；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果您将消息发送到 self，运行时先在当前对象的类中查找方法实现；如果在那里找不到方法，则在其超类中查找（依此类推）。如果您将消息发送到 super，运行时先在超类中查找方法实现。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="Objective-C"></category></entry><entry><title>C++ 学习笔记</title><link href="https://magicalboy.com/cpp.html" rel="alternate"></link><published>2017-11-23T15:54:43+08:00</published><updated>2017-11-23T15:54:43+08:00</updated><author><name>Don</name></author><id>tag:magicalboy.com,2017-11-23:/cpp.html</id><summary type="html">&lt;div class="contents topic" id="id1"&gt;
&lt;p class="topic-title first"&gt;目录&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id13"&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id14"&gt;语法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id15"&gt;注释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id16"&gt;编译预处理指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#namespace" id="id17"&gt;命名空间 Namespace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#main" id="id18"&gt;main 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id19"&gt;语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id20"&gt;标识符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id21"&gt;数据类型&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id9" id="id22"&gt;系统指定的数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id10" id="id23"&gt;变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id11" id="id24"&gt;常量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id12" id="id25"&gt;表达式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;概述&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;C++是20世纪80年代中期（发行于1983）由AT&amp;amp;T贝尔实验室的 Bjarne Stroustrup 开发的。&lt;/p&gt;
&lt;p&gt;属于面向对象语言，它包含 C 语言全部属性。&lt;/p&gt;
&lt;p&gt;使用很广泛，不得不学。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id14"&gt;语法&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id15"&gt;注释&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 这是单行注释&lt;/span&gt;
&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * 这是&lt;/span&gt;
&lt;span class="cm"&gt; * 多行的注释&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id16"&gt;编译预处理指令&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;编译器对 source code 编译之前做的事。用 &amp;quot;#&amp;quot; 开头的命令行来表示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;filename&amp;gt; // 尖括号表示包含的是 C++ 标准库的头文件&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;book …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="contents topic" id="id1"&gt;
&lt;p class="topic-title first"&gt;目录&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id13"&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id14"&gt;语法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id15"&gt;注释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id16"&gt;编译预处理指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#namespace" id="id17"&gt;命名空间 Namespace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#main" id="id18"&gt;main 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id19"&gt;语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id20"&gt;标识符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id8" id="id21"&gt;数据类型&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id9" id="id22"&gt;系统指定的数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id10" id="id23"&gt;变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id11" id="id24"&gt;常量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id12" id="id25"&gt;表达式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;概述&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;C++是20世纪80年代中期（发行于1983）由AT&amp;amp;T贝尔实验室的 Bjarne Stroustrup 开发的。&lt;/p&gt;
&lt;p&gt;属于面向对象语言，它包含 C 语言全部属性。&lt;/p&gt;
&lt;p&gt;使用很广泛，不得不学。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id14"&gt;语法&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id15"&gt;注释&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 这是单行注释&lt;/span&gt;
&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * 这是&lt;/span&gt;
&lt;span class="cm"&gt; * 多行的注释&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id16"&gt;编译预处理指令&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;编译器对 source code 编译之前做的事。用 &amp;quot;#&amp;quot; 开头的命令行来表示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;filename&amp;gt; // 尖括号表示包含的是 C++ 标准库的头文件&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;book.h&amp;quot;   // 包含的是用户自己的头文件&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="namespace"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id17"&gt;命名空间 Namespace&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是 C++ 编译系统为各种命名对象（即标识符）所指定的有效范围。std (Standard 的缩写) 表示 C++ 标准库的所有命名对象，使用分号结束。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="main"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id18"&gt;main 函数&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;// 程序执行入口&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;int 返回值给 OS。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id19"&gt;语句&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;函数体内包括两类语句：
- 声明语句：告诉编译系统本函数使用哪些数据。
- 可执行语句：导致某些动作发生，在翻译成机器语言指令后执行。包括赋值语句，return语句等。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;miles&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 声明语句&lt;/span&gt;
&lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;miles&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// 输入语句&lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;miles&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 输出语句&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id20"&gt;标识符&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;标识符用来给程序中的各种数据元素和对象命名的。&lt;/p&gt;
&lt;p&gt;保留字，即关键字属于 C++ 的特殊标识符。比如：const, float, include, int, namespace, retrun 等。程序员自定义的标识符，如上例中的 miles。&lt;/p&gt;
&lt;p&gt;标识符语法规则：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;必须以字母或下划线开头。&lt;/li&gt;
&lt;li&gt;标识符中只能包含字母，数字或下划线。（上一条说了不能使用数字开头）&lt;/li&gt;
&lt;li&gt;不能使用 C++ 保留字。&lt;/li&gt;
&lt;li&gt;大小定敏感。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;命名规则：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;最好取有意义的名称，见名知义。&lt;/li&gt;
&lt;li&gt;建议使用 “匈牙利符号” 的命名规则，即非首单词的第一个字母大写。比如：dollarsPerHour.&lt;/li&gt;
&lt;li&gt;不管使用什么命名规则，一定要保持命名规则的一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id21"&gt;数据类型&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id9"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id22"&gt;系统指定的数据类型&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;整型 int&lt;/li&gt;
&lt;li&gt;实型 float&lt;/li&gt;
&lt;li&gt;布尔类型 bool (George Boole）&lt;/li&gt;
&lt;li&gt;字符型 char (1 byte)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id23"&gt;变量&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id24"&gt;常量&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id25"&gt;表达式&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="C++"></category></entry></feed>