<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>    Objective C
</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width">
            <link rel="stylesheet" href="https://magicalboy.com/theme/css/normalize.css">
        <link href='//fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>
        <link href='//fonts.googleapis.com/css?family=Oswald' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://magicalboy.com/theme/css/font-awesome.min.css">
        <link rel="stylesheet" href="https://magicalboy.com/theme/css/main.css">

    <link rel="stylesheet" href="https://magicalboy.com/theme/css/blog.css">
    <link rel="stylesheet" href="https://magicalboy.com/theme/css/github.css">
        <link href="https://magicalboy.com//feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="MAG's Note Atom Feed" />
        <script src="https://magicalboy.com/theme/js/vendor/modernizr-2.6.2.min.js"></script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

        <div id="wrapper">
<header id="sidebar" class="side-shadow">
    <hgroup id="site-header">
        <a id="site-title" href="https://magicalboy.com"><h1><i class="icon-mobile-phone"></i> Don</h1></a>
        <p id="site-desc"> 关注移动应用开发 </p>
    </hgroup>
    <nav>
        <ul id="nav-links">
        </ul>
    </nav>
	<nav>
      <!-- <ul>
          <li><a target="_blank" href="https://magicalboy.com">MAGICALBOY</a></li>
          <li><a href="https://plus.google.com/u/0/108274467552316757908">icon-google-plus-sign</a></li>
          <li><a href="https://github.com/donly">icon-github</a></li>
          <li><a href="mailto:donly@magicalboy.com">icon-envelope-alt</a></li>
          <li><a href="atom.xml">icon-rss</a></li>
      </ul> -->
      <ul id="nav-services" class="centered-nav">
              <li><a href="https://plus.google.com/u/0/108274467552316757908" target="_brank"><i class="icon-google-plus-sign svc-badge"></i></a></li>
              <li><a href="https://github.com/donly" target="_brank"><i class="icon-github svc-badge"></i></a></li>
              <li><a href="mailto:donly@magicalboy.com" target="_brank"><i class="icon-envelope-alt svc-badge"></i></a></li>
              <li><a href="atom.xml" target="_brank"><i class="icon-rss svc-badge"></i></a></li>
      </ul>
	</nav>
</header>
    <div id="post-container">
        <ol id="post-list">
            <li>
                <article class="post-entry">
                    <header class="entry-header">
                        <time class="post-time" datetime="2016-11-24T14:25:00+08:00" pubdate>
                            四, 24 11 2016
                        </time>
                        <a href="https://magicalboy.com/Objective-C.html" rel="bookmark"><h1>Objective C</h1></a>
                    </header>

                    <section class="post-content">
                        <div class="contents topic" id="id1">
<p class="topic-title first">目录</p>
<ul class="simple">
<li><a class="reference internal" href="#id2" id="id17">介绍</a></li>
<li><a class="reference internal" href="#id3" id="id18">类</a><ul>
<li><a class="reference internal" href="#id4" id="id19">声明</a></li>
<li><a class="reference internal" href="#id5" id="id20">实现</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6" id="id21">属性</a><ul>
<li><a class="reference internal" href="#id7" id="id22">声明</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8" id="id23">方法</a><ul>
<li><a class="reference internal" href="#id9" id="id24">类方法</a></li>
<li><a class="reference internal" href="#block" id="id25">Block 块</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocol" id="id26">Protocol 协议</a><ul>
<li><a class="reference internal" href="#id10" id="id27">声明</a></li>
<li><a class="reference internal" href="#id11" id="id28">使用</a></li>
</ul>
</li>
<li><a class="reference internal" href="#category" id="id29">Category 分类</a><ul>
<li><a class="reference internal" href="#id12" id="id30">声明</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13" id="id31">Objective C 类型</a><ul>
<li><a class="reference internal" href="#id14" id="id32">类型和字面常量</a></li>
<li><a class="reference internal" href="#id15" id="id33">编译器指令</a></li>
<li><a class="reference internal" href="#id16" id="id34">其它</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id17">介绍</a></h2>
<p>Objective-C 作为 C 程序设计语言的超集，支持与 C 相同的基本语法。您会看到所有熟悉的元素，例如基本类型（<tt class="docutils literal">int</tt>、<tt class="docutils literal">float</tt> 等）、结构、函数、指针，以及流程控制结构，如 <tt class="docutils literal"><span class="pre">if...else</span></tt> 语句和 <tt class="docutils literal">for</tt> 语句。还可以直接使用 C 标准库，例如 stdlib.h 和 stdio.h。</p>
<p>Objective-C 为 ANSI C 添加了下述语法和功能：</p>
<ul class="simple">
<li>定义新的类</li>
<li>类和实例方法</li>
<li>方法调用（称为发消息）</li>
<li>属性声明（以及通过它们自动合成存取方法）</li>
<li>静态和动态类型化</li>
<li>块 (block)，已封装的、可在任何时候执行的多段代码</li>
<li>基本语言的扩展，例如协议和类别</li>
</ul>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id18">类</a></h2>
<p>如同其他大多数面向对象语言那样，Objective-C 中的类，支持数据的封装，并定义对这些数据执行的操作。对象是类的运行时实例。它包含自己的实例变量（由其类声明）的内存副本，以及类方法的指针。您可以采用两步法（称为分配和初始化）创建对象。</p>
<p>Objective-C 中某个类包括两个不同的部分：接口和实现。接口部分包含类声明，并定义该类的公共接口。如同 C 代码那样，您定义头文件和源代码文件，将公共声明与代码的实现细节分开。如果是私有的，将它们放在实现文件中。这些文件的文件扩展名，列在下表中。</p>
<table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="95%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">扩展名</th>
<th class="head">源类型</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>.h</td>
<td>头文件。头文件包含类、类型、函数和常量声明。</td>
</tr>
<tr><td>.m</td>
<td>实现文件。可以同时包含 Objective-C 代码和 C 代码。有时也称为源文件。</td>
</tr>
<tr><td>.mm</td>
<td>实现文件。除了包含 Objective-C 代码和 C 代码以外，还可以包含 C++ 代码。仅当您实际引用您的 Objective-C 代码中的 C++ 类或功能时，才使用此扩展名。</td>
</tr>
</tbody>
</table>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id19">声明</a></h3>
<p>如下图中的语法声明名为 MyClass 的类，它是从基础类（或根类）NSObject 继承而来的。（根类是供其他类直接或间接继承的类。）类声明以编译器指令 &#64;interface 开始，以 &#64;end 指令结束。类名称后面（以冒号分隔），是父类的名称。在 Objective-C 中，一个类只能有一个父类。</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<img alt="类的声明" class="align-center" src="http://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOSCh/chapters/WriteObjective-CCode/Art/class_decl_2x.png" style="width: 496px; height: 208px;" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>在 &#64;interface 指令和 &#64;end 指令之间，编写属性和方法的声明。这些声明组成了类的公共接口。公共接口相关的自定函数、常量或数据类型的声明放在 &#64;interface ...&#64;end 块之外。</p>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id20">实现</a></h3>
<p>类实现的语法和声明相似。以 &#64;implementation 编译器指令开始（接着是该类的名称），以 &#64;end 指令结束。中间是方法实现。（函数实现应在 &#64;implementation ...&#64;end 块之外。）一个实现应该总是将导入它的接口文件作为代码的第一行。</p>
<div class="highlight"><pre><span></span><span class="cp">#import &quot;MyClass.h&quot;</span>

<span class="k">@implementation</span> <span class="bp">MyClass</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithString:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">aName</span>
<span class="p">{</span>
    <span class="c1">// code goes here</span>
<span class="p">}</span>

<span class="p">+</span> <span class="p">(</span><span class="bp">MyClass</span> <span class="o">*</span><span class="p">)</span><span class="nf">myClassWithString:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">aName</span>
<span class="p">{</span>
    <span class="c1">// code goes here</span>
<span class="p">}</span>

<span class="k">@end</span>
</pre></div>
<p>当您想要在源代码中包括头文件时，请在头文件或源文件的前几行之中，指定一个导入 (#import) 指令，#import 指令类似于 C 的 #include 指令，不过前者确保同一文件只被包括一次。如果您要导入框架的大部分或所有头文件，请导入框架的包罗头文件 (umbrella header file)，它具有与框架相同的名称。导入（假设的）QuartzCore 框架的头文件的语法是：</p>
<div class="highlight"><pre><span></span><span class="cp">#import &lt;QuartzCore/QuartzCore.h&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id21">属性</a></h2>
<p>属性通常是指某些由对象封装或储存的数据。它可以是标志（如名称或颜色），也可以是与一个或多个其他对象的关系。一个对象的类定义一个接口，该接口使其对象的用户能获取并设定所封装属性的值。执行这些操作的方法，称为 <strong>存取方法</strong>。</p>
<p>存取方法有两种类型，命名约定：</p>
<ul class="simple">
<li>“getter” 存取方法返回属性的值，且名称与属性相同。</li>
<li>“setter” 存取方法设定属性的新值，且形式为 setPropertyName:，其中属性名称的第一个字母大写。</li>
</ul>
<p>正确命名的存取方法是 Cocoa 和 Cocoa Touch 框架的多种技术的关键元素，如 <strong>键－值编码</strong>  (KVC)，它的机制是，通过对象的名称间接访问对象的属性。</p>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id22">声明</a></h3>
<p>Objective-C 提供属性声明(&#64;property)编译器指令作为一种方便的写法，用于存取方法的声明和实现。</p>
<div class="highlight"><pre><span></span><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">userName</span><span class="p">;</span>
</pre></div>
<p>使用属性声明，指定您想要的行为。编译器接着可以根据该声明，创建或合成实际的 getter 和 setter 方法。已声明的属性减少了您必须编写的样板文件代码量，因此使代码更简洁、更少机会出错。</p>
<p>编译器自动合成所声明的属性。在合成属性时，它创建自己的存取方法，以及“支持”该属性的专有实例变量。实例变量的名称与属性的名称相同，但具有下划线前缀 (_)。只有在对象初始化和取消分配的方法中，您的应用程序应该直接访问实例变量（而不是其属性）。</p>
<p>注意：在 Xcode4.4 之后不需要 <tt class="docutils literal">&#64;synthesize property</tt>，会自动生成 <tt class="docutils literal">&#64;synthesize property = _property</tt>。</p>
<p>如果您想要让实例变量采用不同名称，可以绕过自动合成，并明确地合成属性。在类实现中使用 &#64;synthesize 编译器指令，让编译器产生存取方法，以及进行特殊命名的实例变量。例如：</p>
<div class="highlight"><pre><span></span><span class="k">@synthesize</span> <span class="n">enabled</span> <span class="o">=</span> <span class="n">_isEnabled</span><span class="p">;</span>
</pre></div>
<p>同时，在声明属性时，您可以指定存取方法的自定名称，通常是使 Boolean 属性的 getter 方法遵循约定形式，如下所示：</p>
<div class="highlight"><pre><span></span><span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">getter</span><span class="o">=</span><span class="n">isEnabled</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">enabled</span><span class="p">;</span> <span class="c1">// Assign new value, change name of getter method</span>
</pre></div>
<p>对于包含对象的变量，Objective-C 既支持动态类型化，也支持静态类型化。</p>
<ul class="simple">
<li>静态变量：静态类型化的变量，要在变量类型声明中包括类名称。</li>
<li>动态变量：动态类型化的变量，则要给对象使用类型 id。</li>
</ul>
<div class="highlight"><pre><span></span><span class="bp">MyClass</span> <span class="o">*</span><span class="n">myObject1</span><span class="p">;</span>  <span class="c1">// Static typing</span>
<span class="kt">id</span>       <span class="n">myObject2</span><span class="p">;</span>  <span class="c1">// Dynamic typing</span>
<span class="bp">NSString</span> <span class="o">*</span><span class="n">userName</span><span class="p">;</span>  <span class="c1">// From Your First iOS App (static typing)</span>
</pre></div>
<p>请注意第一个声明中的星号 (*)。在 Objective-C 中，执行对象引用的只能是指针。不能完全理解也不用担心，并非一定要成为指针专家才能开始 Objective-C 编程。码农只需要记住，在静态类型化的对象的声明中，变量的名称前面应放置一个星号。id 类型意味着一个指针。</p>
</div>
</div>
<div class="section" id="id8">
<h2><a class="toc-backref" href="#id23">方法</a></h2>
<p>Objective-C 中有两种类型的方法：实例方法和类方法。</p>
<ul class="simple">
<li><strong>实例方法</strong>，由类的实例来执行。换言之，在调用实例方法之前，必须先创建该类的实例。实例方法是最常见的方法类型。</li>
<li><strong>类方法</strong>，可由它所在的类直接执行。它不需要对象的实例作为消息的接收者。</li>
</ul>
<p>方法声明包含方法类型标识符、返回类型、一个或多个签名关键词，以及参数类型和名称信息。以下是 insertObject:atIndex: 实例方法的声明。</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<img alt="方法声明语法" class="align-center" src="http://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOSCh/chapters/WriteObjective-CCode/Art/method_decl_2x.png" style="width: 492px; height: 252px;" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>对于实例方法，声明前面是减号 (-)；对于类方法，对应指示器是加号 (+)。
一个方法的实际名称 (insertObject:atIndex:) 由方法签名关键词组成，之间用冒号字符分隔。冒号字符表明有参数存在。在上述示例中，该方法采用两个参数。如果方法没有参数，则省略第一个签名关键词后面的冒号。</p>
<p>当您想要调用一个方法时，通过给实现该方法的对象发送一则消息来实现。消息包含方法名称，以及方法所需的参数信息（类型要匹配）。您发送到一个对象的所有消息，都被动态地分派，这样使 Objective-C 类的多态行为更加容易。（多态性是指不同类型的对象响应同一消息的能力。）有时被调用的方法，是由接收消息对象的类之超类来实现。</p>
<p>要发消息，需要一个消息表达式。<strong>消息表达式</strong> 使用方括号（[ 和 ]）将消息本身（以及任何所需参数）括起来，同时将接收消息的对象放在最左边方括号右侧。</p>
<div class="highlight"><pre><span></span><span class="p">[</span><span class="n">myArray</span> <span class="nl">insertObject</span><span class="p">:</span><span class="n">anObject</span> <span class="nl">atIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
<p>为避免声明大量局部变量来储存临时结果，Objective-C 让您嵌套消息表达式。每个嵌套表达式的返回值，都用作另一个消息的一个参数或接收对象。</p>
<div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">myAppObject</span> <span class="n">theArray</span><span class="p">]</span> <span class="nl">insertObject</span><span class="p">:[</span><span class="n">myAppObject</span> <span class="n">objectToInsert</span><span class="p">]</span> <span class="nl">atIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
<p>Objective-C (2.0) 还提供用于调用存取方法的点记法语法。<strong>存取方法</strong> 获取并设定对象的状态，因此对于封装很重要，是所有对象的重要功能。对象隐藏或封装其状态，并显示接口，该接口是访问该状态的所有实例都通用的。使用点记法语法，您可以将上个示例重新编写为如下形式：</p>
<div class="highlight"><pre><span></span><span class="p">[</span><span class="n">myAppObject</span><span class="p">.</span><span class="n">theArray</span> <span class="nl">insertObject</span><span class="p">:</span><span class="n">myAppObject</span><span class="p">.</span><span class="n">objectToInsert</span> <span class="nl">atIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
<p>使用点记法语法进行赋值：</p>
<div class="highlight"><pre><span></span><span class="n">myAppObject</span><span class="p">.</span><span class="n">theArray</span> <span class="o">=</span> <span class="n">aNewArray</span><span class="p">;</span>

<span class="c1">// 相当于</span>
<span class="p">[</span><span class="n">myAppObject</span> <span class="nl">setTheArray</span><span class="p">:</span><span class="n">aNewArray</span><span class="p">];</span>
</pre></div>
<p>在点记法表达式中，您不能使用对动态类型化的对象（类型为 id 的对象）的引用。</p>
<p>TODO: 介绍方法属性</p>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id24">类方法</a></h3>
<p>Objective C 的类方法，类似于 C++ 中的静态类方法。</p>
<p>一般将类方法用作工厂方法创建类的新实例，或，访问与该类关联的一些共享信息。</p>
<div class="highlight"><pre><span></span><span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">myArray</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>  <span class="c1">// nil is essentially the same as NULL</span>

<span class="c1">// Create a new array and assign it to the myArray variable.</span>
<span class="n">myArray</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</pre></div>
</div>
<div class="section" id="block">
<h3><a class="toc-backref" href="#id25">Block 块</a></h3>
<p>块是封装工作单元的对象，即可在任何时间执行的代码段。它们在本质上是可移植的匿名函数，可作为方法和函数的参数传入，或可从方法和函数中返回。块本身具有一个已类型化的参数列表，且可能具有推断或声明的返回类型。您还可以将块赋值给变量，然后像调用函数一样调用它。</p>
<p>插入符号 (^) 是用作块的语法标记。块的参数、返回值和正文（即执行的代码）存在其他类似的语法约定。下图解释了该语法，尤其是在将块赋值给变量时。</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<img alt="Block 声明语法" class="align-center" src="http://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOSCh/chapters/WriteObjective-CCode/Art/blocks_2x.png" style="width: 570px; height: 210px;" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>您接着可以调用块变量，就像它是一个函数一样：</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">myBlock</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// result is 28</span>
</pre></div>
<p>Block 可以在低版本 iOS 中使用，它只需要编译器 Xcode 支持。</p>
<p>TODO: 深入</p>
</div>
</div>
<div class="section" id="protocol">
<h2><a class="toc-backref" href="#id26">Protocol 协议</a></h2>
<p>协议是一组尚未实现的方法列表，任何的类均可采纳该协议并给出方法的具体实现。</p>
<p>协议经常应用于委托及事件触发。</p>
<p>Objective-C中协议的概念与Java中接口的概念并不完全相同。</p>
<div class="section" id="id10">
<h3><a class="toc-backref" href="#id27">声明</a></h3>
<p>类似于接口的声明，但没有父类，并且不能定义实例变量，尽管可以声明属性。</p>
<div class="highlight"><pre><span></span><span class="k">@protocol</span> <span class="nc">MyProtocol</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">myProtocolMethod</span><span class="p">;</span>

<span class="k">@end</span>
</pre></div>
<p>另外，Protocol 也可以在声明时继承别的 Protocol。</p>
<div class="highlight"><pre><span></span><span class="c1">// 注意此处的 NSObject 是一个 Protocol</span>
<span class="k">@protocol</span> <span class="nc">MyProtocol</span> <span class="o">&lt;</span><span class="bp">NSObject</span><span class="o">&gt;</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">myProtocolMethod</span><span class="p">;</span>

<span class="k">@end</span>
</pre></div>
</div>
<div class="section" id="id11">
<h3><a class="toc-backref" href="#id28">使用</a></h3>
<p>将该协议的名称放在尖括号 (&lt;...&gt;) 中，并且放在它继承的类的名称后面：</p>
<div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">SomeClass</span> : <span class="nc">SomeSuperClass</span> <span class="o">&lt;</span><span class="n">MyProtocol</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="category">
<h2><a class="toc-backref" href="#id29">Category 分类</a></h2>
<p>一个分类可以将方法的实现分解进一系列分离的文件。可让扩展类的接口而无需要对类进行实例化。</p>
<p>Objective-C借用并扩展了Smalltalk实现中的“分类”概念。</p>
<p>将类别用作一种手段，来对头文件内的相关方法声明进行分组。甚至还可以将不同的类别声明放在不同的头文件中。框架在其所有头文件中使用这些技巧，来达到清晰明确。</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<img alt="系统框架中的类别" src="static/images/category.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Objective C 中的 Category 仅允许增加方法，不允许增加成员变量。</p>
<div class="section" id="id12">
<h3><a class="toc-backref" href="#id30">声明</a></h3>
<p>声明类别语法，是使用圆括号将类别名称括起来。</p>
<div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="bp">NSArray</span> <span class="nl">(NSExtendedArray)</span>
<span class="p">-</span> <span class="p">(</span><span class="bp">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">arrayByAddingObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">anObject</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="k">@end</span>
</pre></div>
<p>类扩展匿名类别，在实现 (.m) 文件中声明专有属性和专有方法。类扩展看起来类似于类别，只是圆括号之间没有文本。在高版本的Xcode自动生成的 UIViewController 子类实现中可以看到：</p>
<div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">MyAppDelegate</span> <span class="p">()</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">)</span> <span class="n">MyDataObject</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

<span class="k">@end</span>
</pre></div>
<p>在运行时，分类中的方法与类原有的方法并无区别，其代码可以访问包括私有类成员变量在内的所有成员变量。虽然分类可以访问类的私有成员，但通常利用属性的访问方法来访问是一种更好的做法，可以使得分类与原有类更加独立。</p>
<p>若分类声明了与类中原有方法同名的函数，则分类中的方法会被调用。因此分类不仅可以增加类的方法，也可以代替原有的方法。这个特性可以用于修正原有代码中的错误，更可以从根本上改变程序中原有类的行为。若两个分类中的方法同名，则被调用的方法是不可预测的。</p>
<p>允许动态的、按需的加载分类；若不需要某一分类提供的功能，可以简单的不编译之。</p>
</div>
</div>
<div class="section" id="id13">
<h2><a class="toc-backref" href="#id31">Objective C 类型</a></h2>
<p>Objective-C 有几个不能用作变量名称的术语，保留用于特殊用途。其中包括已定义的类型以及与这些类型相配的字面常量，和以 &#64; 符号为前缀的编译器指令。</p>
<div class="section" id="id14">
<h3><a class="toc-backref" href="#id32">类型和字面常量</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">类型</th>
<th class="head">字面常量及描述</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>id</td>
<td><strong>动态对象</strong> 类型。动态类型化的对象和静态类型化的对象的否定字面常量，都是 nil。</td>
</tr>
<tr><td>Class</td>
<td><strong>动态类</strong> 类型。其否定字面常量是 Nil。</td>
</tr>
<tr><td>SEL</td>
<td>选择器的数据类型 (typedef)；此数据类型表示运行时的方法签名。其否定字面常量是 NULL。</td>
</tr>
<tr><td>BOOL</td>
<td>Boolean 类型。字面常量值是 YES 和 NO。</td>
</tr>
</tbody>
</table>
<p>在某些情况下，这些类型和字面常量替换 ANSI C 相应的类型和字面常量。将消息发送到 nil，完全没有影响。</p>
</div>
<div class="section" id="id15">
<h3><a class="toc-backref" href="#id33">编译器指令</a></h3>
<ul class="simple">
<li>&#64;interface</li>
<li>&#64;end</li>
<li>&#64;implementation</li>
<li>&#64;protocol</li>
<li>&#64;property</li>
<li>&#64;synthesize</li>
</ul>
</div>
<div class="section" id="id16">
<h3><a class="toc-backref" href="#id34">其它</a></h3>
<ul class="simple">
<li>self : 引用当前对象；它等同于 C++ 中的 this。</li>
<li>super : 引用超类对象；</li>
</ul>
<p>如果您将消息发送到 self，运行时先在当前对象的类中查找方法实现；如果在那里找不到方法，则在其超类中查找（依此类推）。如果您将消息发送到 super，运行时先在超类中查找方法实现。</p>
</div>
</div>

                    </section>
                    <hr/>
                    <aside class="post-meta">
                        <p>Category: <a href="https://magicalboy.com/category/programing-language.html">Programing Language</a></p>
                        <p>Tags: <a href="https://magicalboy.com/tag/objective-c.html">Objective-C</a>, </p>
                        <p>Copyright: <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh/">自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）</a></p>
                    </aside>
                    <hr/>
<div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'magsnote';
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
                </article>
            </li>
        </ol>
    </div>
        </div>
<footer id="site-info">
    <p>
        Proudly powered by <a href="http://getpelican.com/" target="pelican">Pelican</a> and <a href="http://python.org/" target="python">Python</a>. Theme base on <a href="https://github.com/hdra/pelican-cait" target="github">hndr</a>.
    </p>
    <p>
        Textures by <a href="http://subtlepatterns.com/" target="subtlepatterns">Subtle Pattern</a>. Font Awesome by <a href="http://fortawesome.github.io/Font-Awesome/" target="github">Dave Grandy</a>.
    </p>
</footer>        <script src="https://magicalboy.com/theme/js/main.js"></script>
    </body>
</html>